#!/usr/bin/env python3

import argparse
import os
import re
import subprocess
import yaml

AUTOGEN_NOTICE = "; THIS FILE IS GENERATED BY THE BUILD SCRIPT\n\n"

MODULE_TYPE_SRC = 1
MODULE_TYPE_BIN = 2


def add_checksum(path: str) -> None:
    with open(path, "rb") as f:
        data = f.read()

    sum = 0
    for b in data:
        sum += b
    sum &= 0xFF
    checksum = (-sum) & 0xFF

    with open(path, "ab") as f:
        f.write(bytes([checksum]))


def is_valid_module_name(name: str):
    for char in name:
        if not (char.isalpha() or char == "_"):
            return False
        return True


def get_base_directory() -> str:
    return os.path.dirname(os.path.abspath(__file__))


def get_args() -> argparse.Namespace:
    base_directory = get_base_directory()

    input = os.path.join(base_directory, "src", "magnolia.asm")
    output = os.path.join(base_directory, "bin", "magnolia.bin")

    parser = argparse.ArgumentParser(description="Magnolia build tool")

    parser.add_argument(
        "-i", "--input", default=input, help="path of the asm file to assemble"
    )

    parser.add_argument(
        "-o", "--output", default=output, help="path of the output binary"
    )

    return parser.parse_args()


def get_build_conf() -> tuple[int, str]:
    conf_path = os.path.join(get_base_directory(), "build.yml")
    with open(conf_path, "r") as f:
        data = yaml.load(f, Loader=yaml.SafeLoader)
    return data


def create_module(name: str, path: str, type: int) -> str:
    if not is_valid_module_name(name):
        raise ValueError(f"Invalid module name: {name}")

    if not (type == MODULE_TYPE_SRC or type == MODULE_TYPE_BIN):
        raise ValueError(f"Invalid module type: {name}")

    path = os.path.join(get_base_directory(), path)

    if type == MODULE_TYPE_BIN:
        if not os.path.isfile(path):
            raise ValueError(f"Module path must be a file for type 'bin'")
        return path

    if not os.path.isdir(path):
        raise ValueError(f"Module path must be a directory for type 'src'")

    make = subprocess.run(["make"], cwd=path)
    make.check_returncode()

    path = os.path.join(path, f"bin/{name}.bin")

    return path


def create_embeds(modules: list) -> str:
    embeds = AUTOGEN_NOTICE
    for module in modules:
        name = module["name"].upper()
        path = module["path"]
        embeds += f'EMB_{name}: incbin "{path}"\n'
        embeds += f"EMB_{name}_SIZE equ ($ - EMB_{name})\n"
    return embeds


def create_metadata(metadata: dict) -> str:
    title_validation_re = "^[a-zA-Z0-9._\\-\\s]+$"

    content = AUTOGEN_NOTICE

    vendor = metadata["vendor"]
    name = metadata["name"]
    version = metadata["version"]

    if type(metadata["vendor"]) != str:
        raise ValueError("Missing required property: metadata.vendor")

    if type(metadata["name"]) != str:
        raise ValueError("Missing required property: metadata.name")

    if type(metadata["version"]) != str:
        raise ValueError("Missing required property: metadata.version")

    title = f"{vendor} {name} {version}"
    length = len(title)

    if not re.match(title_validation_re, title):
        raise ValueError("Metadata contains invalid characters")

    content += f"TITLE_DATA db 00011111b, {length}, '{title}'"

    return content


def create_pci(pci: dict) -> str:
    content = AUTOGEN_NOTICE

    if not all(isinstance(value, int) for value in pci.values()):
        raise ValueError("PCI Vendor/Device ID and Class must be integers")

    content += f'PCI_VENDOR_ID equ {pci["vendor"]}\n'
    content += f'PCI_DEVICE_ID equ {pci["device"]}\n'
    content += f'PCI_CLASS     equ {pci["class"]}\n'
    content += f'PCI_SUBCLASS  equ {pci["subclass"]}\n'
    content += f'PCI_INTERFACE equ {pci["interface"]}\n'

    return content


def main() -> None:
    args = get_args()
    build_conf = get_build_conf()
    src_path = os.path.join(get_base_directory(), "src")
    embeds_path = os.path.join(src_path, "autogen", "embeds.asm")
    metadata_path = os.path.join(src_path, "autogen", "metadata.asm")
    pci_path = os.path.join(src_path, "autogen", "pci.asm")
    modules = []

    for module in build_conf["modules"]:
        name = module["name"]
        path = module["path"]
        type = 0

        if module["type"] == "src":
            type = MODULE_TYPE_SRC

        if module["type"] == "bin":
            type = MODULE_TYPE_BIN

        modules.append({"name": name, "path": create_module(name, path, type)})

    with open(embeds_path, "w") as f:
        f.write(create_embeds(modules))

    with open(metadata_path, "w") as f:
        f.write(create_metadata(build_conf["metadata"]))

    with open(pci_path, "w") as f:
        f.write(create_pci(build_conf["pci"]))

    assembler = subprocess.run(
        ["nasm", "-f", "bin", args.input, "-o", args.output], cwd=src_path
    )

    assembler.check_returncode()

    add_checksum(args.output)


if __name__ == "__main__":
    main()
